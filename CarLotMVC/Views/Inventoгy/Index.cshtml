@*Дескрипторы @ * и * @ указывают многострочный комментарий:*@

@*Механизм представлений Razor был создан как усовершенствование механизма
    представлений Web Forms и применяет Razor в качестве основного языка. Представления
    Razor не расширяют System. Web. Page (никакой директивы Page не предусмотрено),
    из-за чего появляется возможность тестирования.*@

@*Razor — это синтаксис разметки шаблонов, который на стороне сервера интерпретируется в код C# (или VB.NET).*@

@*Первое отличие между механизмами представлений Web Fbrms и Razor заключается в том, что код вводится с символом @.
    Интеллектуальные возможности Razor устраняют потребность в добавлении закрывающих символов @, тогда как механизм
    представлений Web Forms требует открывающего и закрывающего дескрипторов (<% %>).*@

@*Представления в MVC обычно строго типизированы в отношении используемых ими данных. Ожидаемый тип данных определяется с
    помощью оператора ©model в представлении. Например, представление Index.cshtml применяет в качестве своего
    источника данных тип IEnumerable<Inventory>*@
@model IEnumerable<AutoLotDALModels.Models.Inventory>
@*Для доступа к таким данным в оставшейся части представления используется ключевое слово Model. Обратите внимание, 
    что в ключевом слове Model буква Мзаписывается в верхнем регистре, а в строке ©model применяется буква ш в нижнем
    регистре. При ссылке на данные, содержащиеся в представлении, используется Model (с заглавной буквой М), как в
    следующем коде, который проходит по всем записям Inventory*@



@*Блоки операторов открываются символом @ и помещаются в фигурные скобки,*@
@{
    ViewBag.Title = "Index";
    @*Блоки кода могут содержать смесь разметки и кода. Строки, которые начинаются с
        дескриптора разметки, интерпретируются как разметка HTML, а строки, начинающиеся с кода, трактуются как код*@
    <tr></tr>
}

<h2>Index</h2>
@*Символ @ перед именем переменной эквивалентен вызову Response .Write () и по
    умолчанию все значения в разметке HTML закодированы. Если вы хотите выводить
    незакодированные данные (т.е. потенциально небезопасные), тогда должны применять
    синтаксис @Html .Raw (username). Код Razor и разметка могут использоваться вместе:

    <hl>Hello, @username</hl>*@
<p>
    @*Однострочные операторы снабжаются префиксом в виде символа @ без какого-либо
        закрывающего символа,*@
    @Html.ActionLink("Create New", "Create")
</p>
@*Дескрипторы @: и <text> обозначают текст, который должен быть визуализирован как часть разметки:

    @:Straight Text
    <div>Value:@i</div>
    <text>
    Lines without HTML tag
    </text>

*@

@*Механизм представлений достаточно интеллектуален в различении ситуаций, когда символ @ должен трактоваться как просто знак,
    а когда он обозначает оператор. Великолепным примером могут служить адреса электронной почты. Если механизм Razor
    встречает адрес электронной почты, то он не интерпретирует его как код. Если код выглядит как адрес электронной почты,
    то указание круглых скобок после @ информирует Razor о необходимости трактовки строки как кода.
    Вот пример:

    someone@foo.com

    адрес электронной почты


    someone@(fоо).com

    foo интерпретируется как код Razor и переменная foo заменяется своим значением


        Чтобы отменить знак @, его нужно продублировать, как показано в следующем коде,
        который помещает @foo в представление:

            @@foo

*@

@*Доступно множество встроенных вспомогательных методов HTML, самые распространенные из которых кратко описаны в табл. 29.9.

        Таблица 29.9. Распространенные вспомогательные методы HTML
        Вспомогательные методы HTML                             Описание
        ActionLink                                              Создает дескриптор якоря

        TextBox[For]                                            Каждый из них создает одноименный элемент управления
        TextArea[For]                                           HTML-формы для свойства модели. Версии For являются
        CheckBox[For]                                           строго типизированными
        RadioButton[For]
        DropDownList[For]
        ListBox[For]
        Hidden[For]
        Password[For]
        Label[For]

        Display[For]                                            Визуализирует свойство как допускающее только чтение на основе шаблона.
                                                                Если специальный шаблон не обнаружен, то используется стандартный
                                                                шаблон (основанный на типе данных). Версия For является строго типизированной

        Editor[For]                                             Визуализирует свойство как элементы управления формы на
                                                                основе шаблона. Если специальный шаблон не обнаружен, то
                                                                применяется стандартный шаблон (основанный на типе данных).
                                                                Версия For является строго типизированной



        DisplayForModel                                         Визуализируют разметку отображения или редактирования
        EditotForModel                                          для целой модели. Используют специальный шаблон, когда он
                                                                существует; иначе применяют стандартный шаблон


        DisplayName[For]                                        Получает отображаемое имя, если оно назначено; в противном случае
                                                                отображает имя свойства. Версия For является строго типизированной

        ValidationSummary                                       Создает сводку по проверке достоверности или сообщение,
        ValidationMessageFor                                    когда возникает ошибка при проверке достоверности клиентской
                                                                или серверной стороны

        @Html.BeginForm()                                       Создает дескриптор HTML-формы, содержащий все, что указано в скобках

        @Html.AntiForgeryToken()                                Работает в сочетании с атрибутом ValidateAntiForgeryToken методов действий



    Шаблонные вспомогательные методы полагаются на стандартные шаблоны, если
    только в корректном местоположении не были созданы специальные шаблоны.
*@


@*В то время как вспомогательные методы для отображения всего лишь выводят данные, вспомогательные методы для редактирования
            делают чуть больше, чем просто создание соответствующего элемента управления. Например, вспомогательный метод HTML по
            имени EditorFor () создает поле ввода на основе типа данных свойства, указанного в лямбда-выражении. Скажем, следующая строка:

            @Html.EditorFor(model =>
                                    model.Make, new { htmlAttributes = new { @class = "form-control” } })

        создает такую разметку:

        <input name="Make" class="form-control text-box single-line"
            id="Make" type="text" value=""
        data-val-length-max="50"
            data-val-length="The field Make must be a string with a maximum length of 50."
            data-val="true">

        Прежде чем двигаться дальше, давайте исследуем результирующую разметку. Значения атрибутов name Hid элемента HTML
    поступают из свойства name, значение type — из типа данных свойства, а значение class — из комбинации вспомогательного
    метода HTML и дополнительных атрибутов HTML, добавленных через вспомогательный метод. Атрибут value элемента
    управления устанавливается в значение свойства. В рассматриваемом случае значение получает пустую строку, поскольку
    это новый экземпляр Inventory.

*@

@*Сами по себе вспомогательные методы HTML будут визуализировать простую разметку. Если вы хотите добавить стилизацию
        или другие атрибуты, тогда должны использовать одну из перегруженных версий.

    Вам придется создать новый анонимный объект с парами “имя-значение” разметки HTML, которую требуется визуализировать вместе
    с базовым выводом. Если атрибут HTML представляет собой зарезервированное слово в С#, то он должен быть отменен с помощью
    символа @. Прием выглядит ошибочным, т.к. символ @ применяется для пометки элемента как кода Razor! Например, при желании
    установить класс CSS для элемента метки использовался бы следующий код:

    @Html.LabelFor(model => model.Color,
            htmlAttributes: new { @class = "control-label col-md-2" })

    В результате разметка для метки будет обновлена, чтобы включать атрибут класса CSS.*@

@*Вспомогательные методы HTML в Razor визуализируют разметку. В дополнение к встроенным вспомогательным методам вы
    можете также строить специальные вспомогательные методы HTML с
    целью сокращения (или вообще устранения) повторяющегося кода.*@


@using AutoLotDALModels.Models
@helper ShowInventory(Inventory item)
{@*Воспомагательный метод его вызов закоментирован в цыкле foreach*@
    @item.Make<text>-</text>@item.Color<text> {</text>@item.PetName<text>}</text>
}

@*Функции Razor не возвращают разметку, а взамен служат для инкапсуляции кода с
    целью многократного использования.*@
@functions
{
    public IList<Inventory> SortCars(IList<Inventory> cars)
    {//Сортировка списка записей
        return (from i in cars orderby i.PetName select i).ToList<Inventory>();
    }
}

@*Делегаты Razor работают точно так же, как делегаты С#.*@
@{
    Func<dynamic, object> b = @<strong>@item</strong>;
}

This will be bold: @b("Foo")
@*Разумеется, пример тривиален, но в случае более сложного повторяющегося кода можно получить выигрыш от его помещения внутрь
    делегата. По существу здесь применимы все доводы “за” и “против”, связанные с делегатами С#. После запуска приложения и
    перехода на страницу Inventory/Index можно заметить, что слово Foo выделено полужирным. *@
<table class="table">
    <tr>
        <th>
            @Html.DisplayNameFor(model => model.Make)
        </th>
        <th>
            @Html.DisplayNameFor(model => model.Color)
        </th>
        <th>
            @Html.DisplayNameFor(model => model.PetName)
        </th>
        <th></th>
    </tr>
    @*Для доступа к таким данным в оставшейся части представления используется ключевое слово Model. Обратите внимание,
        что в ключевом слове Model буква Мзаписывается в верхнем регистре, а в строке ©model применяется буква ш в нижнем
        регистре. При ссылке на данные, содержащиеся в представлении, используется Model (с заглавной буквой М), как в
        следующем коде, который проходит по всем записям Inventory*@
        @*Вызов сортировщика списка записей*@
        @foreach (var item in SortCars(Model.ToList()))
        {
            @*Вызов вспомагательного метода *@
            @*@ShowInventory(item)*@
            @Html.DisplayFor(modelItem=>item, "InventoryList")
        }

    </table>
